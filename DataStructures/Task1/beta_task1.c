
#include<stdio.h>
#include <stdlib.h>
/* 
    ! Το πρόγραμμα αντί να χρησιμοποιεί τρεις πίνακες και 2 διασυνδεδεμένες λίστες για την πρόσθεση
    και εκτύπωση του αποτελέσματος, χρησιμοποιεί μία μεταβλητή για την εισαγωγή στοιχείου και μία διασυνδεδεμένη λίστα,
    για την τελική εκτύπωση. Με αποτέλεσμα να εξοικονομεί χρόνο και κυρίως χώρο!
/*



/*
  Το struct node ειναι η δομή των κομβων της λίστας για κάθε μη
  μηδενικό στοιχείο.Περιέχει έναν ακέραιο για την τιμή του στοιχείου,
  δύο ακεραίους για τις συντεταγμένες του στοιχείου στον πίνακα και 
  ένα δείκτη για το επόμενο μη μηδενικό στοιχείο
*/
typedef struct node 
{
    int val;
    int col;
    int row;
    struct node * next;
} node_t;

int main()
{
    //Δήλωση και εισαγωγή του μήκους και του πλάτους του πίνακα Α
	printf("Input height and width of matrix a:\n ");
	int h, w, a;
	int f = 1;
	scanf("%d", &h);
	scanf("%d", &w);
    //Δημιουργία "κόμβου"(μπλοκ μεταβλητών με τη βοήθεια του struct) με όνομα head. Η συνάρτηση malloc δίνει ακριβως το μέγεθος που χρειάζονται οι αντίστοιχες μεταβλητές. 
	node_t * head = malloc(sizeof(node_t));

	for (int i = 0; i <h; ++i)
	{
		for(int j=0; j<w; ++j)
		{
			/*
                Καθώς "διατρέχουμε"" τους δύο πίνακες, δημιουργούμε 2 ψευδοτυχαίες τιμές 
                ο ή 1 (για να υπάρχει μεγαλύτερη πιθανότητα να δημιουργηθεί 0)
                τις προσθέτουμε και τις αποθηκεύουμε στη μεταβλητη α
                Οι 2 αυτές τυχαίες τιμές αντιπροσωπεύουν τις αντίστοιχες τιμές που θα εισάγαμε στον πίανακα α και β
                εξικονομώντας χώρο
            */
			a = rand() %2 + rand() %2;
            /*
              Ελέγχει αν ο αριθμός που εισάγει ο χρήστης είναι διάφορος του μηδενός. Στην 
              συγκεκριμένη περίπτωση η μεταβλητή f λειτουργεί σαν flag.Στην πρώτη επανάληψη,
              όταν το f ισούται με 1,η συνθηκη της else γινεται αληθής και δημιουργείται 
              ο πρώτος κομβος της λιστας (head). Στις επόμενες επαναλήψεις που η f ειναι 0
              περνάμε στην συνάρτηση push τα απαραίτητα στοιχεία για τον επόμενο κόμβο.
            */
			if (a!=0)
			{
				if(f==0)
				{
					push(head, a, i, j);
				}
				else
				{
	                head->val = a;
	                head->col = i;
	                head->row = j;
	                head->next=NULL;
	                f = 0;
				}
			}

		}
	}
	print_list(head, h, w);

}


/* 
    Συνάρτηση για την εκτύπωση της διασυνδεδεμένης λίστας αποτέλεσμα() του πίνακα απότέλεσμα c)
*/
int print_list(node_t * head, int h, int w) 
{
    //Τρέχων κόμβος
    node_t * current = head;
    //Ακολουθούν 2 for loop όσο και το μέγεθος τον πινάκων που έγιναν εισαγωγή
    for (int i = 0; i < h; ++i)
    {
    	for (int j = 0; j < w; ++j)
    	{
            /*
                Αν στον τωρινό κόμβο οι μεταβλητές-συντεταγμένες col και row είναι ίσες με τους μετρητές των for loop
                τυπώνουμε το μη μηδενικό στοιχείο
                αλλιώς τυπώνουμε μηδέν.
            */
    		if ( (current->row==j) && (current->col==i) )
    		{
    			printf("%d %s",current->val," |");
    			current = current->next;	
    		}
    		else
    		{
    			printf(" 0 |");
    		}
    	}
    	printf("\n");
    }
    
    return 0;
}


/*
  Η συνάρτηση push δέχεται τον πρώτο κόμβο (την κεφαλή της διασυνδεδεμένης λίστας) το μη μηδενικό στοιχείο, την γραμμή και στήλη του στοιχείου
  , δημιουργεί και προσθέτει νέο κόμβο
  */
int push(node_t * head, int val, int i, int j) 
{
    node_t * current = head;
    /*
      Ελέγχει τον κέθε κόμβο αν ο pointer που περιέχει είναι διάφορος NULL. Όταν 
      βρει τον κόμβο που περιέχει pointer ίσο με NULL τερματίζει τη while.
    */
    while (current->next != NULL) 
    {
        current = current->next;
    }
    //Δημιουργεί τον νέο κόμβο
    current->next = malloc(sizeof(node_t));
    current->next->val = val;
    current->next->col = i;
    current->next->row = j;
    current->next->next = NULL;
    return 0;  
}
